package quic

var maskbytes = []byte{
	// 第一字节特别设计：确保 QUIC 包头异或后不包含 0x40 和 0x80 位
	// 0xC0 ^ 0x33 = 0xF3, 0x40 ^ 0x33 = 0x73, 0xE0 ^ 0x33 = 0xD3
	0x01, 0x23, 0x24, 0xa5, 0x24, 0xe3, 0x63, 0x84,
	0x35, 0x86, 0x97, 0xf8, 0x99, 0x8a, 0x2b, 0xcc,
	0x3d, 0x8e, 0x29, 0x3f, 0x6b, 0x8c, 0x2d, 0x2e,
	0x3e, 0x8f, 0x1b, 0x31, 0x9d, 0x8e, 0x2f, 0xcf,
	0x3f, 0x80, 0x0d, 0x33, 0x9f, 0x80, 0x21, 0x4f,
	0x30, 0x31, 0x23, 0x35, 0x91, 0x12, 0x23, 0xdf,
	0x31, 0x82, 0x25, 0x37, 0x93, 0x84, 0x25, 0xdf,
	0x32, 0x83, 0xa7, 0x39, 0x55, 0x86, 0x27, 0xef,
	0x33, 0x84, 0x29, 0x3b, 0x97, 0xa8, 0x29, 0xdf,
}

// 混淆长度
var MaskLength = 20

// 写一个混淆byte的函数
func FF_maskBytes(b []byte) {
	length := len(b)
	if length == 0 {
		return
	}
	if length > MaskLength {
		length = MaskLength
	}
	// 将b的前length位  异或maskbytes的前length位
	for i := 0; i < length; i++ {
		b[i] ^= maskbytes[i]
	}
}

func FF_maskBytesWithLength(b []byte, length int) {
	if length == 0 {
		return
	}
	if length > MaskLength {
		length = MaskLength
	}
	// 将b的前length位  异或maskbytes的前length位
	for i := 0; i < length; i++ {
		b[i] ^= maskbytes[i]
	}
}
